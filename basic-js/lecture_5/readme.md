#### Обьекты

Как мы знаем в JavaScript существует семь типов данных. Шесть из них называются «примитивными», так как содержат только одно значение (будь то строка, число или что-то другое).

Объекты же используются для хранения коллекций различных значений и более сложных сущностей. В JavaScript объекты используются очень часто, это одна из основ языка. Поэтому мы должны понять их, прежде чем углубляться куда-либо ещё.

Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – это пара <b>«ключ: значение»</b>, где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.

Мы можем представить объект в виде ящика с подписанными папками. Каждый элемент данных хранится в своей папке, на которой написан ключ. По ключу папку легко найти, удалить или добавить в неё что-либо.

Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

# Вычисление выражений

    let user = new Object(); // синтаксис "конструктор объекта"

    let user = {};  // синтаксис "литерал объекта"

# Литералы и свойства

При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:

    let user = { // объект
        name: "Maksym", // под ключом "name" хранится значение "Maksym"
        age: 22 // под ключом "age" хранится значение 22
    };

Свойства объекта также иногда называют полями объекта.

У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.

В объекте user сейчас находятся два свойства:

Первое свойство с именем "name" и значением "Maksym".
Второе свойство с именем "age" и значением 22.
Можно сказать, что наш объект user – это ящик с двумя папками, подписанными «name» и «age»

Для обращения к свойствам используется запись «через точку»:

    console.log(user.name)
    console.log(user.age)

Для удаления свойства мы можем использовать оператор delete:

    delete user.age

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает,
Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:

    let user = {};

    // присваивание значения свойству
    user["is admin"] = true;

    // получение значения свойства
    alert(user["is admin"]); // true

    // удаление свойства
    delete user["is admin"];

Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:

    let key = "likes birds";
    user[key] = true;

Запись «через точку» такого не позволяет.

В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.

    const makeUser = (name, age) => {
        return {
            name: name,
            age: age
            // ...другие свойства
        };
    }

    let user = makeUser("Maksym", 30);
    alert(user.name); // Maksym

примере выше название свойств name и age совпадают с названиями переменных, которые мы подставляем в качестве значений этих свойств. Такой подход настолько распространён, что существуют специальные короткие свойства для упрощения этой записи.

Вместо name:name мы можем написать просто name:

    const makeUser = (name, age) => {
        return {
          name,
          age
        };
    }

Проверка существования свойства
Особенность объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет! При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства – сравнением его с undefined:

    let user = {};
    console.log(user.noSuchProperty === undefined );

Также существует специальный оператор "in" для проверки существования свойства в объекте.

Синтаксис оператора:

    "key" in object

Пример:

    let user = { name: "Maksym", age: 30 };

    console.log( "age" in user ); // true, user.age существует
    console.log( "blabla" in user ); // false, user.blabla не существует

Цикл «for…in»
Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).

Синтаксис:

    for (key in object) {
        // тело цикла выполняется для каждого свойства объекта
    }

К примеру, давайте выведем все свойства объекта user:

    let user = {
    name: "Maksym",
    age: 22,
    isAdmin: true
    };

    for (let key in user) {
    // ключи
    console.log( key );  // name, age, isAdmin
    // значения ключей
    console.log( user[key] ); // Maksym, 22, true

}

# Копирование по ссылке

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются <b>«по ссылке»</b>.

Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

Например:

    let message = "Hello!";
    let phrase = message;

<b>Объекты ведут себя иначе.</b>

Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

Проиллюстрируем это:

    let user = {
        name: "Maksym"
    };

Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.

Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

Если мы представляем объект как ящик, то переменная – это ключ к нему. Копирование переменной дублирует ключ, но не сам ящик.

Например:

    let user = { name: "Maksym" };

    let admin = user; // копируется ссылка

Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект

Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:

    let user = { name: 'Maksym' };

    let admin = user;

    admin.name = 'Pete'; // изменено по ссылке из переменной "admin"

    console.log(user.name); // 'Pete', изменения видны по ссылке из переменной "user"

# Клонирование и объединение объектов, Object.assign

Как мы узнали ранее, при копировании переменной объекта создаётся ещё одна ссылка на тот же самый объект.

Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

Это выполнимо, но немного сложно, так как в JavaScript нет встроенного метода для этого. На самом деле, такая нужда возникает редко. В большинстве случаев нам достаточно копирования по ссылке.

Но если мы действительно этого хотим, то нам нужно создавать новый объект и повторять структуру дублируемого объекта, перебирая его свойства и копируя их.

Например так:

    let user = {
        name: "Maksym",
        age: 22
    };

    let clone = {}; // новый пустой объект

    // скопируем все свойства user в него
    for (let key in user) {
        clone[key] = user[key];
    }

    // теперь в переменной clone находится абсолютно независимый клон объекта.
    clone.name = "Pete"; // изменим в нём данные

    console.log( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Maksym.

Кроме того, для этих целей мы можем использовать метод <b>Object.assign.</b>

Например, объединим несколько объектов в один:

    let user = { name: "John" };

    let permissions1 = { canView: true };
    let permissions2 = { canEdit: true };

    // копируем все свойства из permissions1 и permissions2 в user
    Object.assign(user, permissions1, permissions2);

    // now user = { name: "Maksym", canView: true, canEdit: true }

Мы также можем использовать Object.assign для простого клонирования:

    let user = {
        name: "Maksym",
        age: 22
    };

    let clone = Object.assign({}, user);

Документация:
<a href="https://developer.mozilla.org/ru/docs/Learn/JavaScript/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B">Основы обьектов</a>

# Методы объекта, "this"

Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:

    // Объект пользователя
    let user = {
        name: "Maksym",
        age: 22
    };

И так же, как и в реальном мире, пользователь может совершать действия: выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п.

Такие действия в JavaScript представлены свойствами-функциями объекта.

    let user = {
        name: "Maksym",
        age: 22
    };

    user.sayHi = function() {
    alert("Hi!");
    };

    user.sayHi(); // Hi!

Здесь мы просто использовали Function Expression (функциональное выражение), чтобы создать функцию для приветствия, и присвоили её свойству user.sayHi нашего объекта.

Затем мы вызвали её. Теперь пользователь может говорить!

Функцию, которая является свойством объекта, называют методом этого объекта.

Итак, мы получили метод sayHi объекта user.

Конечно, мы могли бы заранее объявить функцию и использовать её в качестве метода, примерно так:

    let user = {
        // ...
    };

    function sayHi() {
        console.log("Hi!");
    };

    user.sayHi = sayHi;
    user.sayHi(); // Hi!

<a href="https://devcolibri.com/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BE%D0%BE%D0%BF-%D0%B8-%D1%81-%D1%87%D0%B5%D0%BC-%D0%B5%D0%B3%D0%BE-%D0%B5%D0%B4%D1%8F%D1%82/">Объектно-ориентированное программирование</a>

# Ключевое слово «this» в методах

Как правило, методу объекта необходим доступ к информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).

Например, коду внутри user.sayHi() может понадобиться имя пользователя, которое хранится в объекте user.

Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который использовался для вызова метода.

Например:

    let user = {
    name: "Maksym",
    age: 22,

    sayHi() {
        // this - это "текущий объект"
        console.log(this.name);
    }

    };

    user.sayHi(); // Maksym

Здесь во время выполнения кода user.sayHi() значением this будет являться user (ссылка на объект user).

Технически также возможно получить доступ к объекту без ключевого слова this, ссылаясь на него через внешнюю переменную (в которой хранится ссылка на этот объект):

    let user = {
        name: "Maksym",
        age: 22,
        sayHi() {
            console.log(user.name); // используем переменную "user" вместо ключевого слова "this"
        }
    };

…Но такой код будет ненадёжным. Если мы решим скопировать ссылку на объект user в другую переменную, например, admin = user, и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.

Это показано ниже:

    let user = {
        name: "Maksym",
        age: 22,

        sayHi() {
            console.log( user.name ); // приведёт к ошибке
        }
    };

    let admin = user;
    user = null; // обнулим переменную для наглядности, теперь она не хранит ссылку на объект.

    admin.sayHi(); // Ошибка! Внутри sayHi() используется user, которая больше не ссылается на объект

Если мы используем this.name вместо user.name внутри alert, тогда этот код будет работать.

В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Оно может использоваться в любой функции.

В этом коде нет синтаксической ошибки:

    function sayHi() {
        console.log(this.name);
    }

Значение this вычисляется во время выполнения кода и зависит от контекста.

Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» при вызовах:

    let user = { name: "Maksym" };
    let admin = { name: "Oleh" };

    function sayHi() {
        console.log( this.name );
    }

    // используем одну и ту же функцию в двух объектах
    user.f = sayHi;
    admin.f = sayHi;

    // вызовы функции, приведённые ниже, имеют разное значение this
    // "this" внутри функции является ссылкой на объект, который указан "перед точкой"
    user.f(); // Maksym  (this == user)
    admin.f(); // Oleh  (this == admin)

    admin['f'](); // Oleh (неважен способ доступа к методу - через точку или квадратные скобки)

Правило простое: при вызове obj.f() значение this внутри f равно obj. Так что, в приведённом примере это user или admin.

У стрелочных функций нет «this»
Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.

Например, здесь arrow() использует значение this из внешнего метода user.sayHi():

    let user = {
        firstName: "Oleh",
        sayHi() {
            let arrow = () => console.log(this.firstName);
            arrow();
        }
    };
    user.sayHi(); // Oleh

Это является особенностью стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь отдельное значение this, а хотим брать его из внешнего контекста. Позднее в главе Повторяем стрелочные функции мы увидим больше примеров на эту тему.

<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects">Работа с обьектами (Документация)</a>
